@startuml

package "GroupeLitterale" {


    Class ConstructeurLitterale{
    
        -string : char[30] 
        +ConstructeurLitterale() 
        +Constructeur_entier() 
        +Constructeur_reel() 
        +Constructeur_atome() 
        +Constructeur_expression(Atome & a) 
    }

    Class Litterale {
    
         -str: char[30] 
         -reel: double 
         -nom: Atome* 
         +virtual bouton() 
         +distinct() 
         +virtual empiler() 
         +virtual memoriser() 
         +virtual ~Litterale() 

    }


    Class Atome{
    
        -fonction: int  //indiquer le role joue
        +if_identifi(): int 
    }

    Class Expression{
    
        -guillemet1: char 
        -guillemet2: char 
        -r: Reel*  
        -e: Entier* 
        -ra: Rationnel*  
        -p: Program*  
        -a: Atome*  
        +if_predefini(): int 
        +if_deja_utilise(): int 
    }

    Class Numerique{
    
    }

    Class Reel{
        -val: double 
        -point: char 
        +simplifier() 
    }

    Class Rationel{
        -if_simple: int 
        -slash: char 
        +simplifier() 
        }
    
    Class Entier{
        -signe: char 

    }

    Class Programme{
        -crochet1: char 
        -crochet2: char 
    }

}



Class Item{
    -lit : Litterale
    +obtenirLitterale() : Litterale&
}

package "GroupeOperateur" {

Class Operateur{
    -listeOperateur : QMap<Qstring>
    +opEVAL(Litterale & l): void
}

Class OperateurNumerique {
    +opPLUS(Litterale & l1, Litterale & l2) : Litterale&
    +opMOINS(Litterale & l1, Litterale & l2) : Litterale&
    +opMUL(Litterale & l1, Litterale & l2) : Litterale&
    +opDIVISION(Litterale & l1, Litterale & l2) : Litterale&
    +opDIV(Litterale & l1, Litterale & l2) : Litterale&
    +opMOD(Litterale & l1, Litterale & l2) : Litterale&
    +opNEG(Litterale & l) : Litterale&
}

Class OperateurLogique {
    +opEGAL(Litterale & l1, Litterale & l2) : Litterale&
    +opDIFFERENT(Litterale & l1, Litterale & l2) : Litterale&
    +opINFEGAL(Litterale & l1, Litterale & l2) : Litterale&
    +opSUPEGAL(Litterale & l1, Litterale & l2) : Litterale&
    +opSUP(Litterale & l1, Litterale & l2) : Litterale&
    +opINF(Litterale & l1, Litterale & l2) : Litterale&
    +opAND(Litterale & l1, Litterale & l2) : Litterale&
    +opOR(Litterale & l1, Litterale & l2) : Litterale&
    +opNOT(Litterale & l) : Litterale&


}

Class OperateurPile {
    +opDUP() : void
    +opDROP() : void
    +opSWAP() : void 
    +opCLEAR() : void
}

Class OperateurConditionnel {
    +opIFT() : void
}



}


Class Pile{
    -listeItems : vector<Item>
    +pop() : Item&
    +push(item : Item) : void
    +estVide() : bool
    +taille() : size_t



}

Class Interpreteur{
    -pointeurPile : Pile*
    +interprete(commandeEntree : QString)
    +execute(operande : QString)
}

Class Controleur{
    -refIntp : Interpreteur&
    -refPile : Pile&
    -message : QString
    +Controleur(intp : Interpreteur&, p : Pile&)
    +commande(c : const QString&)
    +setMessage(m : const QString&)
    +getMessage() : QString const
}

Class Persistance{

}

package "groupeAffichage" {

    Class Affichage{

    }

    Class Qt {
	-barreMessage : QLineEdit *
	-barreEntree : QLineEdit *
	-vuePile : QTableWidget *
	-coucheDisposition : QVBoxLayout*
	-pile : Pile *
	-controleur : Controleur *
	+Qcomputer(QWidget * parent = 0)
	+~QComputer()
	+refresh()
	+getNextCommande()
    }

}

Litterale <|-- Programme
Litterale <|-- Numerique
Litterale <|-- Expression
Litterale <|-- Atome
Numerique <|-- Reel
Numerique <|-- Rationel
Numerique <|-- Entier

Operateur <|-- OperateurNumerique
Operateur <|-- OperateurLogique
Operateur <|-- OperateurPile
Operateur <|-- OperateurConditionnel 

ConstructeurLitterale *-- Litterale
Interpreteur *-- Operateur
Interpreteur *-- ConstructeurLitterale
Item *-- Litterale
Pile o-- Item
Pile <--> Interpreteur
Controleur *--> Interpreteur
Controleur *--> Pile
Controleur <-- Persistance
Controleur *--> Affichage
Affichage --> Qt

@enduml
